# pylint: skip-file
# Задание №1
def get_views_count(n: int) -> str:
    """
    Нужно реализовать надпись в формате "N просмотров". Падеж слова "просмотр" зависит
    от числа N. Например, 1 просмотр, 2 просмотра и т.п.
    """
    return ""


# Задание №2
def format_person(fio: str) -> str:
    """
    Дана ФИО, возможно с маленькой буквы, возможно с большой.
    Написать функцию, которая делает фамилию, имя и отчество с большой буквы,
    а остальные буквы должны быть маленькими.
    "Александр cергеевич ПУШКИН" -> "Александр Cергеевич Пушкин".
    l будем использовать встроенную функцию title()
    """
    return ""


# Задание №3
def clean_name(fio: str) -> str:
    """
    Данные загрузились из БД с лишними символами, а должны быть только русские буквы.
    Напишите функцию, которая удаляет символы, которые не являются русскими буквами.
    "Иsвtrан Ив^%ан Ива?но)вич" -> "Иванов Иван Иванович"
    """
    return ""


# Задание №4
def is_list_growing(lst: list[float]) -> bool:
    """
    Напишите функцию, которая вернет true, если массив является полностью возрастающим,
    т.е. каждый следующий элемент больше предыдущего
    """
    return False


# Задание №5
def move_zeros(lst: list[float]) -> list:
    """
    Дан список, содержащий нули. Сдвинуть все нули вправо, сохранив порядок
    исходного списка:
    move_zeros([1, 0, 0, 2, 3, 0, 1]) -> [1, 2, 3, 1, 0, 0, 0]
    """
    return lst


# Задание №6
def get_pairs_number(lst: list[int], n) -> list[tuple]:
    """
    Дан список целых чисел и определенное заданное число. Найти все пары из списка,
    сумма которых равна этому числу.
    Верните из функции список кортежей.
    Например: get_pairs_number([1, 2, 4, 3, 5, 2], 7) -> [(4,3), (5,2)]
    """
    return []


# Задание №7
def get_pct_growth(s: list[float]) -> list[float]:
    """
    Дан массив цен акций, вывести список, содержащий темпы прироста от периода к периоду.
    Для первого элемента списка выведите значение None. Округлите до целых.
    Например: [100, 150, 300, 400] -> [None, 50%, 100%, 33%]
    """
    return []


# Задание №8
def contains_in_list(small: list[int], big: list[int]) -> bool:
    """
    Выведите true, если массив содержится в другом массиве
    в том же порядке. l обязательно элементы должны идти один
    за другим.

    contains_in_list([3, 4, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == true
    """


# Задание №9
def parse_dict(d_str: str) -> dict[str, str]:
    """
    Напишите функцию, которая парсит строку в формате ключ-значение
    и возвращает соответствующий словарь.
    Для продвинутых: при ошибке ввода (повторяющиеся ключи, например)
    выбрасывать исключение. Подумайте о других возможных ошибках.
    Пример:
    actual = parse_dict('first_name="Alex", last_name="Pushkin"')
    expected = {
        'first_name': 'Alex',
        'last_name': 'Pushkin'
    }
    """


# Задание №10
def are_brackets_correct(s: str) -> bool:
    """
    Напишите функцию, которая возвращает true, если скобочная последовательность
    является правильной, т.е. все открывающиеся скобки соответствуют закрывающимся.
    Скобки могут быть круглыми и квадратными.
    ((( ))) - правильно.
    [][][] - правильно
    [()][] - правильно
    [(][)] - неправильно
    """


# Задание №11
def calculate(expression: str) -> float:
    """
    Реализовать калькулятор, который на входе принимает математическое
    выражение, записанное в виде строки, а возвращает вычисленное значение.
    Правила записи строки следующие:
    - скобок нет
    - только положительные числа
    - возможные операции: сложение и вычитание
    Например:
    calculate("1+2") == 3
    calculate("1+2+8") == 11
    calculate("12-6+8") == 14
    calculate("1+21-20+9") == 11
    """
